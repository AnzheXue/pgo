/--------------------------------- MODULE raft ---------------------------------
\* This is the formal specification for the Raft consensus algorithm.
\*
\* Copyright 2014 Diego Ongaro.
\* This work is licensed under the Creative Commons Attribution-4.0
\* International License https://creativecommons.org/licenses/by/4.0/

EXTENDS Naturals, FiniteSets, Sequences, TLC

CONSTANTS Terms
CONSTANTS Slots
CONSTANTS N

\* A reserved value.
CONSTANTS Nil

(***************************************************************************
\* 4/12
    \* 14:05 - 14:40
    \* 15:25 - 16:00
\* 4/13
    \* 13:25 - 15:30
\* 4/15
    \* 15:45 - 17:00
\* 4/16
    \* 11:20 - 11:45
    \* 13:05 - 13:45
    \* 14:00 - 14:45
\* 4/17
    \* 13:30 -


--mpcal Raft {
    define {
        Servers == 0..N-1
        Follower == 0
        Candidate == 1
        Leader == 2
        RequestVote == 0
        RequestVoteResponse == 1
        AppendEntries == 2
        AppendEntriesResponse == 3
        SubSeq(seq,first,last) == [i \in 1..(1+first-last) |-> seq[first+last-1]]
        Term(log,index) == (IF Len(log) >= index /\ Len(log) > 0 THEN log[index].term ELSE 0)
    }

    macro SendRequestVotes(network, cterm, candidateId, lastLogIndex, lastLogTerm, idx) {
        while (idx < Cardinality(Servers)) {
            network[idx] := [type |-> RequestVote, term |-> cterm, sender |-> candidateId, entries |-> <<>>,
                             prevIndex |-> lastLogIndex, prevTerm |-> lastLogTerm, granted |-> FALSE];
            idx := idx + 1;
        };
    }

    macro SendAppendEntries(network, cterm, candidateId, nextIndex, matchIndex, log, leaderCommit, idx) {
        while (idx < Cardinality(Servers)) {
            if (idx # candidateId) {
                network[idx] := [type |-> RequestVote, term |-> cterm, sender |-> candidateId, entries |-> SubSeq(log, nextIndex[idx], Len(log)),
                                 prevIndex |-> nextIndex[idx]-1, prevTerm |-> Term(log, nextIndex[idx]-1), granted |-> FALSE];
            };

            idx := idx + 1;
        };
    }

    macro SubSeq(t, t2, end, idx) {
        while(idx <= end) {
            t2 := Append(t2,Head(t));
            t := Tail(t);
            idx := idx + 1;
        };
    }

    mapping macro FIFOChannel {
        read {
            await Len($variable) > 0;
            with (msg = Head($variable)) {
                $variable := Tail($variable);
                yield msg;
            };
        }

        write {
            yield Append($variable, $value);
        }
    }

    mapping macro Log {
        read {
            assert(FALSE);
        }

        write {
            yield $variable \union {$value};
        }
    }

    mapping macro ID {
        read {
            yield $variable;
        }

        write {
            yield $value;
        }
    }

    mapping macro Input {
        read {
            with (msg = Head($variable)) {
                $variable := Tail($variable);
                yield msg;
            };
        }

        write { assert(FALSE); }
    }

    archetype Node(ref network[_], ref applied[_], ref values)
    variable currentTerm = 0,
             votedFor = Nil,
             log = <<>>,
             state = Follower,
             commitIndex = 0,
             lastApplied = 0,
             v,
             nextIndex,
             matchIndex,
             idx,
             votes = [t \in 0..Terms |-> {}],
             msg; {
Start:while (commitIndex < Slots /\ currentTerm < Terms) {
        either {
N1:         msg := network[self];
            if (msg.type = AppendEntries) {
                if (msg.term < currentTerm) {
N2:                 network[msg.sender] := [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> FALSE,
                                            entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil];
                } else if (Len(log) < msg.prevIndex \/ log[msg.prevIndex].term # msg.prevTerm) {
                    \* Following entries don't have matching terms
                    log := SubSeq(log,1,msg.prevIndex-1);
N3:                 network[msg.sender] := [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> FALSE,
                                            entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil];
                } else if (Len(log) = msg.prevIndex) {
                    log := log \o msg.entries;
N4:                 network[msg.sender] := [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> TRUE,
                                            entries |-> <<>>, prevIndex |-> msg.prevIndex + Len(msg.entries), prevTerm |-> Nil];
                };

N5:             if (msg.term > currentTerm) {
                    state := Follower;
                    currentTerm := msg.term;
                };

                if (msg.leaderCommit > commitIndex) {
                    commitIndex := IF msg.leaderCommit < Len(log) THEN msg.leaderCommit ELSE Len(log[self]);
loop1:              while(lastApplied <= commitIndex) {
                        \* with (tmp = applied) {
                        \*     applied := [tmp EXCEPT ![lastApplied] = log[lastApplied]];
                        \* };
                        applied[lastApplied] := log[lastApplied];
                        lastApplied := lastApplied + 1;
                    };
                };
            } else if (msg.type = RequestVote) {
                if (msg.term < currentTerm) {
N6:                 network[msg.sender] := [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm, granted |-> FALSE,
                                            entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil];
                } else if ((votedFor = Nil \/ votedFor = msg.sender)
                         /\ (msg.prevTerm > Term(log, Len(log))
                             \/ (msg.prevTerm = Term(log, Len(log)) /\ msg.prevIndex >= Len(log)))) {
                    log := SubSeq(log, 1, msg.prevIndex-1);
 N7:                network[msg.sender] := [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm, granted |-> TRUE,
                                            entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil];
                };
            } else if (msg.type = AppendEntriesResponse /\ state = Leader) {
                if (msg.granted) {
                    nextIndex[msg.sender] := msg.prevIndex + 1;
                    matchIndex[msg.sender] := msg.prevIndex;
loop2:              while (Cardinality({i \in Servers: matchIndex[idx] > commitIndex})*2 > Cardinality(Servers) /\ Term(log, commitIndex+1) = currentTerm) {
                        commitIndex := commitIndex + 1;
                    };
loop3:              while(lastApplied <= commitIndex) {
                        \* with (tmp = applied) {
                        \*     applied := [tmp EXCEPT ![lastApplied] = log[lastApplied]];
                        \* };
                        applied[lastApplied] := log[lastApplied];
                        lastApplied := lastApplied + 1;
                    };
                } else {
                    nextIndex[msg.sender] := IF nextIndex[msg.sender] - 1 > 1 THEN nextIndex[msg.sender] - 1 ELSE 1;
N8:                 network[msg.sender] := [type |-> RequestVote, term |-> currentTerm, sender |-> self, entries |-> SubSeq(log, nextIndex[msg.sender], Len(log)),
                                            prevIndex |-> nextIndex[msg.sender]-1, prevTerm |-> Term(log, nextIndex[msg.sender]-1), granted |-> FALSE];
                };
            } else if (msg.type = RequestVoteResponse) {
                if (msg.granted /\ state = Candidate) {
                    votes[msg.term] := votes[msg.term] \union {msg.sender};
                    if (Cardinality(votes[msg.term])*2 > Cardinality(Servers)) {
                        state := Leader;
                        matchIndex := [s3 \in Servers |-> 0];
                        nextIndex := [s4 \in Servers |-> 0];
                    };
                };
            };
        } or {
            \* Election timeout
N9:         if (state # Leader) {
                state := Candidate;
                currentTerm := currentTerm + 1;
                votes[currentTerm] := {self};
                votedFor := self;
                idx := 0;
loop4:          SendRequestVotes(network, self, currentTerm, Len(log), Term(log, Len(log)), idx);
            };
        } or {
            \* Act as leader
N10:        if (state = Leader) {
                v := values;
                log := Append(log, [val |-> v, term |-> currentTerm]);
                matchIndex[self] := Len(log);
                nextIndex[self] := Len(log)+1;
                idx := 0;
loop5:          SendAppendEntries(network, currentTerm, self, nextIndex, matchIndex, log, commitIndex, idx);
            };
        };
      };
    }


    variables
        mailboxes = [id \in Servers |-> <<>>];

    fair process (server \in Servers) == instance Node(ref mailboxes[_], [s \in 0..Slots |-> {}], {1})
        mapping mailboxes[_] via FIFOChannel
        mapping @2[_] via Log
        mapping @3 via Input;
}


\* BEGIN PLUSCAL TRANSLATION
--algorithm Raft {
  variables mailboxes = [id \in Servers |-> <<>>];
  define{
    Servers == (0) .. ((N) - (1))
    Follower == 0
    Candidate == 1
    Leader == 2
    RequestVote == 0
    RequestVoteResponse == 1
    AppendEntries == 2
    AppendEntriesResponse == 3
    SubSeq(seq, first, last) == [i \in (1) .. ((1) + ((first) - (last))) |-> (seq)[(first) + ((last) - (1))]]
    Term(log, index) == IF ((Len(log)) >= (index)) /\ ((Len(log)) > (0)) THEN ((log)[index]).term ELSE 0
  }
  
  fair process (server \in Servers)
    variables currentTerm = 0; votedFor = Nil; log = <<>>; state = Follower; commitIndex = 0; lastApplied = 0; v; nextIndex; matchIndex; idx; votes = [t \in (0) .. (Terms) |-> {}]; msg; applied = [s \in (0) .. (Slots) |-> {}]; values = {1};
  {
    Start:
      if (((commitIndex) < (Slots)) /\ ((currentTerm) < (Terms))) {
        either {
          goto N1;
        } or {
          goto N9;
        } or {
          goto N10;
        };
      } else {
        goto Done;
      };
    N1:
      await (Len((mailboxes)[self])) > (0);
      with (msg00 = Head((mailboxes)[self])) {
        mailboxes := [mailboxes EXCEPT ![self] = Tail((mailboxes)[self])];
        with (yielded_mailboxes0 = msg00) {
          msg := yielded_mailboxes0;
          if (((msg).type) = (AppendEntries)) {
            if (((msg).term) < (currentTerm)) {
              goto N2;
            } else {
              if (((Len(log)) < ((msg).prevIndex)) \/ ((((log)[(msg).prevIndex]).term) # ((msg).prevTerm))) {
                log := SubSeq(log, 1, ((msg).prevIndex) - (1));
                goto N3;
              } else {
                if ((Len(log)) = ((msg).prevIndex)) {
                  log := (log) \o ((msg).entries);
                  goto N4;
                } else {
                  goto N5;
                };
              };
            };
          } else {
            if (((msg).type) = (RequestVote)) {
              if (((msg).term) < (currentTerm)) {
                goto N6;
              } else {
                if ((((votedFor) = (Nil)) \/ ((votedFor) = ((msg).sender))) /\ ((((msg).prevTerm) > (Term(log, Len(log)))) \/ ((((msg).prevTerm) = (Term(log, Len(log)))) /\ (((msg).prevIndex) >= (Len(log)))))) {
                  log := SubSeq(log, 1, ((msg).prevIndex) - (1));
                  goto N7;
                } else {
                  goto Start;
                };
              };
            } else {
              if ((((msg).type) = (AppendEntriesResponse)) /\ ((state) = (Leader))) {
                if ((msg).granted) {
                  nextIndex := [nextIndex EXCEPT ![(msg).sender] = ((msg).prevIndex) + (1)];
                  matchIndex := [matchIndex EXCEPT ![(msg).sender] = (msg).prevIndex];
                  goto loop2;
                } else {
                  nextIndex := [nextIndex EXCEPT ![(msg).sender] = IF (((nextIndex)[(msg).sender]) - (1)) > (1) THEN ((nextIndex)[(msg).sender]) - (1) ELSE 1];
                  goto N8;
                };
              } else {
                if (((msg).type) = (RequestVoteResponse)) {
                  if (((msg).granted) /\ ((state) = (Candidate))) {
                    votes := [votes EXCEPT ![(msg).term] = ((votes)[(msg).term]) \union ({(msg).sender})];
                    if (((Cardinality((votes)[(msg).term])) * (2)) > (Cardinality(Servers))) {
                      state := Leader;
                      matchIndex := [s3 \in Servers |-> 0];
                      nextIndex := [s4 \in Servers |-> 0];
                      goto Start;
                    } else {
                      goto Start;
                    };
                  } else {
                    goto Start;
                  };
                } else {
                  goto Start;
                };
              };
            };
          };
        };
      };
    N2:
      with (value9 = [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value9)];
        goto N5;
      };
    N3:
      with (value00 = [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value00)];
        goto N5;
      };
    N4:
      with (value10 = [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm, granted |-> TRUE, entries |-> <<>>, prevIndex |-> ((msg).prevIndex) + (Len((msg).entries)), prevTerm |-> Nil]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value10)];
        goto N5;
      };
    N5:
      if (((msg).term) > (currentTerm)) {
        state := Follower;
        currentTerm := (msg).term;
        if (((msg).leaderCommit) > (commitIndex)) {
          commitIndex := IF ((msg).leaderCommit) < (Len(log)) THEN (msg).leaderCommit ELSE Len((log)[self]);
          goto loop1;
        } else {
          goto Start;
        };
      } else {
        if (((msg).leaderCommit) > (commitIndex)) {
          commitIndex := IF ((msg).leaderCommit) < (Len(log)) THEN (msg).leaderCommit ELSE Len((log)[self]);
          goto loop1;
        } else {
          goto Start;
        };
      };
    loop1:
      if ((lastApplied) <= (commitIndex)) {
        with (value20 = (log)[lastApplied]) {
          applied := [applied EXCEPT ![lastApplied] = ((applied)[lastApplied]) \union ({value20})];
          lastApplied := (lastApplied) + (1);
          goto loop1;
        };
      } else {
        goto Start;
      };
    N6:
      with (value30 = [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm, granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value30)];
        goto Start;
      };
    N7:
      with (value40 = [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm, granted |-> TRUE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value40)];
        goto Start;
      };
    loop2:
      if ((((Cardinality({i \in Servers : ((matchIndex)[idx]) > (commitIndex)})) * (2)) > (Cardinality(Servers))) /\ ((Term(log, (commitIndex) + (1))) = (currentTerm))) {
        commitIndex := (commitIndex) + (1);
        goto loop2;
      } else {
        goto loop3;
      };
    loop3:
      if ((lastApplied) <= (commitIndex)) {
        with (value50 = (log)[lastApplied]) {
          applied := [applied EXCEPT ![lastApplied] = ((applied)[lastApplied]) \union ({value50})];
          lastApplied := (lastApplied) + (1);
          goto loop3;
        };
      } else {
        goto Start;
      };
    N8:
      with (value60 = [type |-> RequestVote, term |-> currentTerm, sender |-> self, entries |-> SubSeq(log, (nextIndex)[(msg).sender], Len(log)), prevIndex |-> ((nextIndex)[(msg).sender]) - (1), prevTerm |-> Term(log, ((nextIndex)[(msg).sender]) - (1)), granted |-> FALSE]) {
        mailboxes := [mailboxes EXCEPT ![(msg).sender] = Append((mailboxes)[(msg).sender], value60)];
        goto Start;
      };
    N9:
      if ((state) # (Leader)) {
        state := Candidate;
        currentTerm := (currentTerm) + (1);
        votes := [votes EXCEPT ![currentTerm] = {self}];
        votedFor := self;
        idx := 0;
        goto loop4;
      } else {
        goto Start;
      };
    loop4:
      if ((idx) < (Cardinality(Servers))) {
        with (value70 = [type |-> RequestVote, term |-> self, sender |-> currentTerm, entries |-> <<>>, prevIndex |-> Len(log), prevTerm |-> Term(log, Len(log)), granted |-> FALSE]) {
          mailboxes := [mailboxes EXCEPT ![idx] = Append((mailboxes)[idx], value70)];
          idx := (idx) + (1);
          goto loop4;
        };
      } else {
        goto Start;
      };
    N10:
      if ((state) = (Leader)) {
        with (msg10 = Head(values)) {
          values := Tail(values);
          with (yielded_values0 = msg10) {
            v := yielded_values0;
            log := Append(log, [val |-> v, term |-> currentTerm]);
            matchIndex := [matchIndex EXCEPT ![self] = Len(log)];
            nextIndex := [nextIndex EXCEPT ![self] = (Len(log)) + (1)];
            idx := 0;
            goto loop5;
          };
        };
      } else {
        goto Start;
      };
    loop5:
      if ((idx) < (Cardinality(Servers))) {
        if ((idx) # (self)) {
          with (value80 = [type |-> RequestVote, term |-> currentTerm, sender |-> self, entries |-> SubSeq(log, (nextIndex)[idx], Len(log)), prevIndex |-> ((nextIndex)[idx]) - (1), prevTerm |-> Term(log, ((nextIndex)[idx]) - (1)), granted |-> FALSE]) {
            mailboxes := [mailboxes EXCEPT ![idx] = Append((mailboxes)[idx], value80)];
            idx := (idx) + (1);
            goto loop5;
          };
        } else {
          idx := (idx) + (1);
          goto loop5;
        };
      } else {
        goto Start;
      };
  }
}

\* END PLUSCAL TRANSLATION

******************************************************************************)

\* BEGIN TRANSLATION
CONSTANT defaultInitValue
VARIABLES pc, mailboxes

(* define statement *)
Servers == (0) .. ((N) - (1))
Follower == 0
Candidate == 1
Leader == 2
RequestVote == 0
RequestVoteResponse == 1
AppendEntries == 2
AppendEntriesResponse == 3
SubSeq(seq, first, last) == [i \in (1) .. ((1) + ((first) - (last))) |-> (seq)[(first) + ((last) - (1))]]
Term(log, index) == IF ((Len(log)) >= (index)) /\ ((Len(log)) > (0)) THEN ((log)[index]).term ELSE 0

VARIABLES currentTerm, votedFor, log, state, commitIndex, lastApplied, v, 
          nextIndex, matchIndex, idx, votes, msg, applied, values

vars == << pc, mailboxes, currentTerm, votedFor, log, state, commitIndex, 
           lastApplied, v, nextIndex, matchIndex, idx, votes, msg, applied, 
           values >>

ProcSet == (Servers)

Init == (* Global variables *)
        /\ mailboxes = [id \in Servers |-> <<>>]
        (* Process server *)
        /\ currentTerm = [self \in Servers |-> 0]
        /\ votedFor = [self \in Servers |-> Nil]
        /\ log = [self \in Servers |-> <<>>]
        /\ state = [self \in Servers |-> Follower]
        /\ commitIndex = [self \in Servers |-> 0]
        /\ lastApplied = [self \in Servers |-> 0]
        /\ v = [self \in Servers |-> defaultInitValue]
        /\ nextIndex = [self \in Servers |-> defaultInitValue]
        /\ matchIndex = [self \in Servers |-> defaultInitValue]
        /\ idx = [self \in Servers |-> defaultInitValue]
        /\ votes = [self \in Servers |-> [t \in (0) .. (Terms) |-> {}]]
        /\ msg = [self \in Servers |-> defaultInitValue]
        /\ applied = [self \in Servers |-> [s \in (0) .. (Slots) |-> {}]]
        /\ values = [self \in Servers |-> {1}]
        /\ pc = [self \in ProcSet |-> "Start"]

Start(self) == /\ pc[self] = "Start"
               /\ IF ((commitIndex[self]) < (Slots)) /\ ((currentTerm[self]) < (Terms))
                     THEN /\ \/ /\ pc' = [pc EXCEPT ![self] = "N1"]
                             \/ /\ pc' = [pc EXCEPT ![self] = "N9"]
                             \/ /\ pc' = [pc EXCEPT ![self] = "N10"]
                     ELSE /\ pc' = [pc EXCEPT ![self] = "Done"]
               /\ UNCHANGED << mailboxes, currentTerm, votedFor, log, state, 
                               commitIndex, lastApplied, v, nextIndex, 
                               matchIndex, idx, votes, msg, applied, values >>

N1(self) == /\ pc[self] = "N1"
            /\ (Len((mailboxes)[self])) > (0)
            /\ LET msg00 == Head((mailboxes)[self]) IN
                 /\ mailboxes' = [mailboxes EXCEPT ![self] = Tail((mailboxes)[self])]
                 /\ LET yielded_mailboxes0 == msg00 IN
                      /\ msg' = [msg EXCEPT ![self] = yielded_mailboxes0]
                      /\ IF ((msg'[self]).type) = (AppendEntries)
                            THEN /\ IF ((msg'[self]).term) < (currentTerm[self])
                                       THEN /\ pc' = [pc EXCEPT ![self] = "N2"]
                                            /\ log' = log
                                       ELSE /\ IF ((Len(log[self])) < ((msg'[self]).prevIndex)) \/ ((((log[self])[(msg'[self]).prevIndex]).term) # ((msg'[self]).prevTerm))
                                                  THEN /\ log' = [log EXCEPT ![self] = SubSeq(log[self], 1, ((msg'[self]).prevIndex) - (1))]
                                                       /\ pc' = [pc EXCEPT ![self] = "N3"]
                                                  ELSE /\ IF (Len(log[self])) = ((msg'[self]).prevIndex)
                                                             THEN /\ log' = [log EXCEPT ![self] = (log[self]) \o ((msg'[self]).entries)]
                                                                  /\ pc' = [pc EXCEPT ![self] = "N4"]
                                                             ELSE /\ pc' = [pc EXCEPT ![self] = "N5"]
                                                                  /\ log' = log
                                 /\ UNCHANGED << state, nextIndex, matchIndex, 
                                                 votes >>
                            ELSE /\ IF ((msg'[self]).type) = (RequestVote)
                                       THEN /\ IF ((msg'[self]).term) < (currentTerm[self])
                                                  THEN /\ pc' = [pc EXCEPT ![self] = "N6"]
                                                       /\ log' = log
                                                  ELSE /\ IF (((votedFor[self]) = (Nil)) \/ ((votedFor[self]) = ((msg'[self]).sender))) /\ ((((msg'[self]).prevTerm) > (Term(log[self], Len(log[self])))) \/ ((((msg'[self]).prevTerm) = (Term(log[self], Len(log[self])))) /\ (((msg'[self]).prevIndex) >= (Len(log[self])))))
                                                             THEN /\ log' = [log EXCEPT ![self] = SubSeq(log[self], 1, ((msg'[self]).prevIndex) - (1))]
                                                                  /\ pc' = [pc EXCEPT ![self] = "N7"]
                                                             ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                                                  /\ log' = log
                                            /\ UNCHANGED << state, nextIndex, 
                                                            matchIndex, votes >>
                                       ELSE /\ IF (((msg'[self]).type) = (AppendEntriesResponse)) /\ ((state[self]) = (Leader))
                                                  THEN /\ IF (msg'[self]).granted
                                                             THEN /\ nextIndex' = [nextIndex EXCEPT ![self] = [nextIndex[self] EXCEPT ![(msg'[self]).sender] = ((msg'[self]).prevIndex) + (1)]]
                                                                  /\ matchIndex' = [matchIndex EXCEPT ![self] = [matchIndex[self] EXCEPT ![(msg'[self]).sender] = (msg'[self]).prevIndex]]
                                                                  /\ pc' = [pc EXCEPT ![self] = "loop2"]
                                                             ELSE /\ nextIndex' = [nextIndex EXCEPT ![self] = [nextIndex[self] EXCEPT ![(msg'[self]).sender] = IF (((nextIndex[self])[(msg'[self]).sender]) - (1)) > (1) THEN ((nextIndex[self])[(msg'[self]).sender]) - (1) ELSE 1]]
                                                                  /\ pc' = [pc EXCEPT ![self] = "N8"]
                                                                  /\ UNCHANGED matchIndex
                                                       /\ UNCHANGED << state, 
                                                                       votes >>
                                                  ELSE /\ IF ((msg'[self]).type) = (RequestVoteResponse)
                                                             THEN /\ IF ((msg'[self]).granted) /\ ((state[self]) = (Candidate))
                                                                        THEN /\ votes' = [votes EXCEPT ![self] = [votes[self] EXCEPT ![(msg'[self]).term] = ((votes[self])[(msg'[self]).term]) \union ({(msg'[self]).sender})]]
                                                                             /\ IF ((Cardinality((votes'[self])[(msg'[self]).term])) * (2)) > (Cardinality(Servers))
                                                                                   THEN /\ state' = [state EXCEPT ![self] = Leader]
                                                                                        /\ matchIndex' = [matchIndex EXCEPT ![self] = [s3 \in Servers |-> 0]]
                                                                                        /\ nextIndex' = [nextIndex EXCEPT ![self] = [s4 \in Servers |-> 0]]
                                                                                        /\ pc' = [pc EXCEPT ![self] = "Start"]
                                                                                   ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                                                                        /\ UNCHANGED << state, 
                                                                                                        nextIndex, 
                                                                                                        matchIndex >>
                                                                        ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                                                             /\ UNCHANGED << state, 
                                                                                             nextIndex, 
                                                                                             matchIndex, 
                                                                                             votes >>
                                                             ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                                                  /\ UNCHANGED << state, 
                                                                                  nextIndex, 
                                                                                  matchIndex, 
                                                                                  votes >>
                                            /\ log' = log
            /\ UNCHANGED << currentTerm, votedFor, commitIndex, lastApplied, v, 
                            idx, applied, values >>

N2(self) == /\ pc[self] = "N2"
            /\ LET value9 == [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm[self], granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value9)]
                 /\ pc' = [pc EXCEPT ![self] = "N5"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

N3(self) == /\ pc[self] = "N3"
            /\ LET value00 == [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm[self], granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value00)]
                 /\ pc' = [pc EXCEPT ![self] = "N5"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

N4(self) == /\ pc[self] = "N4"
            /\ LET value10 == [sender |-> self, type |-> AppendEntriesResponse, term |-> currentTerm[self], granted |-> TRUE, entries |-> <<>>, prevIndex |-> ((msg[self]).prevIndex) + (Len((msg[self]).entries)), prevTerm |-> Nil] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value10)]
                 /\ pc' = [pc EXCEPT ![self] = "N5"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

N5(self) == /\ pc[self] = "N5"
            /\ IF ((msg[self]).term) > (currentTerm[self])
                  THEN /\ state' = [state EXCEPT ![self] = Follower]
                       /\ currentTerm' = [currentTerm EXCEPT ![self] = (msg[self]).term]
                       /\ IF ((msg[self]).leaderCommit) > (commitIndex[self])
                             THEN /\ commitIndex' = [commitIndex EXCEPT ![self] = IF ((msg[self]).leaderCommit) < (Len(log[self])) THEN (msg[self]).leaderCommit ELSE Len((log[self])[self])]
                                  /\ pc' = [pc EXCEPT ![self] = "loop1"]
                             ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                  /\ UNCHANGED commitIndex
                  ELSE /\ IF ((msg[self]).leaderCommit) > (commitIndex[self])
                             THEN /\ commitIndex' = [commitIndex EXCEPT ![self] = IF ((msg[self]).leaderCommit) < (Len(log[self])) THEN (msg[self]).leaderCommit ELSE Len((log[self])[self])]
                                  /\ pc' = [pc EXCEPT ![self] = "loop1"]
                             ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                                  /\ UNCHANGED commitIndex
                       /\ UNCHANGED << currentTerm, state >>
            /\ UNCHANGED << mailboxes, votedFor, log, lastApplied, v, 
                            nextIndex, matchIndex, idx, votes, msg, applied, 
                            values >>

loop1(self) == /\ pc[self] = "loop1"
               /\ IF (lastApplied[self]) <= (commitIndex[self])
                     THEN /\ LET value20 == (log[self])[lastApplied[self]] IN
                               /\ applied' = [applied EXCEPT ![self] = [applied[self] EXCEPT ![lastApplied[self]] = ((applied[self])[lastApplied[self]]) \union ({value20})]]
                               /\ lastApplied' = [lastApplied EXCEPT ![self] = (lastApplied[self]) + (1)]
                               /\ pc' = [pc EXCEPT ![self] = "loop1"]
                     ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                          /\ UNCHANGED << lastApplied, applied >>
               /\ UNCHANGED << mailboxes, currentTerm, votedFor, log, state, 
                               commitIndex, v, nextIndex, matchIndex, idx, 
                               votes, msg, values >>

N6(self) == /\ pc[self] = "N6"
            /\ LET value30 == [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm[self], granted |-> FALSE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value30)]
                 /\ pc' = [pc EXCEPT ![self] = "Start"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

N7(self) == /\ pc[self] = "N7"
            /\ LET value40 == [sender |-> self, type |-> RequestVoteResponse, term |-> currentTerm[self], granted |-> TRUE, entries |-> <<>>, prevIndex |-> Nil, prevTerm |-> Nil] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value40)]
                 /\ pc' = [pc EXCEPT ![self] = "Start"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

loop2(self) == /\ pc[self] = "loop2"
               /\ IF (((Cardinality({i \in Servers : ((matchIndex[self])[idx[self]]) > (commitIndex[self])})) * (2)) > (Cardinality(Servers))) /\ ((Term(log[self], (commitIndex[self]) + (1))) = (currentTerm[self]))
                     THEN /\ commitIndex' = [commitIndex EXCEPT ![self] = (commitIndex[self]) + (1)]
                          /\ pc' = [pc EXCEPT ![self] = "loop2"]
                     ELSE /\ pc' = [pc EXCEPT ![self] = "loop3"]
                          /\ UNCHANGED commitIndex
               /\ UNCHANGED << mailboxes, currentTerm, votedFor, log, state, 
                               lastApplied, v, nextIndex, matchIndex, idx, 
                               votes, msg, applied, values >>

loop3(self) == /\ pc[self] = "loop3"
               /\ IF (lastApplied[self]) <= (commitIndex[self])
                     THEN /\ LET value50 == (log[self])[lastApplied[self]] IN
                               /\ applied' = [applied EXCEPT ![self] = [applied[self] EXCEPT ![lastApplied[self]] = ((applied[self])[lastApplied[self]]) \union ({value50})]]
                               /\ lastApplied' = [lastApplied EXCEPT ![self] = (lastApplied[self]) + (1)]
                               /\ pc' = [pc EXCEPT ![self] = "loop3"]
                     ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                          /\ UNCHANGED << lastApplied, applied >>
               /\ UNCHANGED << mailboxes, currentTerm, votedFor, log, state, 
                               commitIndex, v, nextIndex, matchIndex, idx, 
                               votes, msg, values >>

N8(self) == /\ pc[self] = "N8"
            /\ LET value60 == [type |-> RequestVote, term |-> currentTerm[self], sender |-> self, entries |-> SubSeq(log[self], (nextIndex[self])[(msg[self]).sender], Len(log[self])), prevIndex |-> ((nextIndex[self])[(msg[self]).sender]) - (1), prevTerm |-> Term(log[self], ((nextIndex[self])[(msg[self]).sender]) - (1)), granted |-> FALSE] IN
                 /\ mailboxes' = [mailboxes EXCEPT ![(msg[self]).sender] = Append((mailboxes)[(msg[self]).sender], value60)]
                 /\ pc' = [pc EXCEPT ![self] = "Start"]
            /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                            lastApplied, v, nextIndex, matchIndex, idx, votes, 
                            msg, applied, values >>

N9(self) == /\ pc[self] = "N9"
            /\ IF (state[self]) # (Leader)
                  THEN /\ state' = [state EXCEPT ![self] = Candidate]
                       /\ currentTerm' = [currentTerm EXCEPT ![self] = (currentTerm[self]) + (1)]
                       /\ votes' = [votes EXCEPT ![self] = [votes[self] EXCEPT ![currentTerm'[self]] = {self}]]
                       /\ votedFor' = [votedFor EXCEPT ![self] = self]
                       /\ idx' = [idx EXCEPT ![self] = 0]
                       /\ pc' = [pc EXCEPT ![self] = "loop4"]
                  ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                       /\ UNCHANGED << currentTerm, votedFor, state, idx, 
                                       votes >>
            /\ UNCHANGED << mailboxes, log, commitIndex, lastApplied, v, 
                            nextIndex, matchIndex, msg, applied, values >>

loop4(self) == /\ pc[self] = "loop4"
               /\ IF (idx[self]) < (Cardinality(Servers))
                     THEN /\ LET value70 == [type |-> RequestVote, term |-> self, sender |-> currentTerm[self], entries |-> <<>>, prevIndex |-> Len(log[self]), prevTerm |-> Term(log[self], Len(log[self])), granted |-> FALSE] IN
                               /\ mailboxes' = [mailboxes EXCEPT ![idx[self]] = Append((mailboxes)[idx[self]], value70)]
                               /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                               /\ pc' = [pc EXCEPT ![self] = "loop4"]
                     ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                          /\ UNCHANGED << mailboxes, idx >>
               /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                               lastApplied, v, nextIndex, matchIndex, votes, 
                               msg, applied, values >>

N10(self) == /\ pc[self] = "N10"
             /\ IF (state[self]) = (Leader)
                   THEN /\ LET msg10 == Head(values[self]) IN
                             /\ values' = [values EXCEPT ![self] = Tail(values[self])]
                             /\ LET yielded_values0 == msg10 IN
                                  /\ v' = [v EXCEPT ![self] = yielded_values0]
                                  /\ log' = [log EXCEPT ![self] = Append(log[self], [val |-> v'[self], term |-> currentTerm[self]])]
                                  /\ matchIndex' = [matchIndex EXCEPT ![self] = [matchIndex[self] EXCEPT ![self] = Len(log'[self])]]
                                  /\ nextIndex' = [nextIndex EXCEPT ![self] = [nextIndex[self] EXCEPT ![self] = (Len(log'[self])) + (1)]]
                                  /\ idx' = [idx EXCEPT ![self] = 0]
                                  /\ pc' = [pc EXCEPT ![self] = "loop5"]
                   ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                        /\ UNCHANGED << log, v, nextIndex, matchIndex, idx, 
                                        values >>
             /\ UNCHANGED << mailboxes, currentTerm, votedFor, state, 
                             commitIndex, lastApplied, votes, msg, applied >>

loop5(self) == /\ pc[self] = "loop5"
               /\ IF (idx[self]) < (Cardinality(Servers))
                     THEN /\ IF (idx[self]) # (self)
                                THEN /\ LET value80 == [type |-> RequestVote, term |-> currentTerm[self], sender |-> self, entries |-> SubSeq(log[self], (nextIndex[self])[idx[self]], Len(log[self])), prevIndex |-> ((nextIndex[self])[idx[self]]) - (1), prevTerm |-> Term(log[self], ((nextIndex[self])[idx[self]]) - (1)), granted |-> FALSE] IN
                                          /\ mailboxes' = [mailboxes EXCEPT ![idx[self]] = Append((mailboxes)[idx[self]], value80)]
                                          /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                                          /\ pc' = [pc EXCEPT ![self] = "loop5"]
                                ELSE /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                                     /\ pc' = [pc EXCEPT ![self] = "loop5"]
                                     /\ UNCHANGED mailboxes
                     ELSE /\ pc' = [pc EXCEPT ![self] = "Start"]
                          /\ UNCHANGED << mailboxes, idx >>
               /\ UNCHANGED << currentTerm, votedFor, log, state, commitIndex, 
                               lastApplied, v, nextIndex, matchIndex, votes, 
                               msg, applied, values >>

server(self) == Start(self) \/ N1(self) \/ N2(self) \/ N3(self) \/ N4(self)
                   \/ N5(self) \/ loop1(self) \/ N6(self) \/ N7(self)
                   \/ loop2(self) \/ loop3(self) \/ N8(self) \/ N9(self)
                   \/ loop4(self) \/ N10(self) \/ loop5(self)

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /\ \A self \in ProcSet: pc[self] = "Done"
               /\ UNCHANGED vars

Next == (\E self \in Servers: server(self))
           \/ Terminating

Spec == /\ Init /\ [][Next]_vars
        /\ \A self \in Servers : WF_vars(server(self))

Termination == <>(\A self \in ProcSet: pc[self] = "Done")

\* END TRANSLATION

StateMachineCorrectness == \A i,j \in Servers :
                            \A k \in 0..((IF commitIndex[i] < commitIndex[j] THEN commitIndex[i] ELSE commitIndex[j])-1):
                                log[i][k] = log[j][k]


===============================================================================

\* Changelog:
\*
\* 2014-12-02:
\* - Fix AppendEntries to only send one entry at a time, as originally
\*   intended. Since SubSeq is inclusive, the upper bound of the range should
\*   have been nextIndex, not nextIndex + 1. Thanks to Igor Kovalenko for
\*   reporting the issue.
\* - Change matchIndex' to matchIndex (without the apostrophe) in
\*   AdvanceCommitIndex. This apostrophe was not intentional and perhaps
\*   confusing, though it makes no practical difference (matchIndex' equals
\*   matchIndex). Thanks to Hugues Evrard for reporting the issue.
\*
\* 2014-07-06:
\* - Version from PhD dissertation
