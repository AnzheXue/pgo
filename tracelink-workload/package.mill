package build.`tracelink-workload`

import mill.*
import mill.util.Jvm
import mill.api.BuildCtx

import scalasql.*, PostgresDialect.*
import java.time.LocalDateTime
import scala.util.Using

val wiredtigerRepo = "git@github.com:fhackett/wiredtiger.git"
val wiredtigerBranches = List("tracelink")
val chromatictreeRepo = "git@github.com:ubc-systopia/augmented-chromatic-trees.git"
val chromatictreeBranches = List("main")

val gitRepos = 
  wiredtigerBranches.map((wiredtigerRepo, _))
  ++ chromatictreeBranches.map((chromatictreeRepo, _))

def performPatch(src: os.Path, patchSeq: List[(os.SubPath, os.Path)], destDir: os.Path): PathRef =
  os.copy(from = src, to = destDir, createFolders = true, mergeFolders = true)
  patchSeq.foreach: (patchDest, patchPath) =>
    os.copy(from = patchPath, to = destDir / patchDest, createFolders = true, mergeFolders = true)
  PathRef(destDir)
end performPatch

trait GitRepoModule extends Cross.Module2[String, String]:
  def dir: T[PathRef] = Task:
    val origin = crossValue
    val branch = crossValue2
    val p = os.proc("git", "clone", origin, "-b", branch)
    println(s"$$ ${p.commandChunks.mkString(" ")}")
    p.call(cwd = Task.dest)
    PathRef(os.list(Task.dest).filter(os.isDir).head)
  end dir
end GitRepoModule
object gitRepo extends mill.Cross[GitRepoModule](gitRepos)

trait TraceEvalSpecModule extends Module:
  def spec: T[PathRef]
  def specHPP: T[PathRef] = Task:
    val destFile = Task.dest / "workload-meta.hpp"
    build.pgo.runner().run(List[os.Shellable]("workloadgen", spec().path, "--out-file", destFile))
    PathRef(destFile)
  end specHPP
  def tracesNeeded: T[Int] = 10
end TraceEvalSpecModule

object evalDB extends Module:
  def dbPath: os.Path = BuildCtx.workspaceRoot / "tracelink-workload" / "eval.duckdb"
  def createTablesSQL: T[PathRef] = Task.Source(BuildCtx.workspaceRoot / "tracelink-workload" / "createTables.sql")

  final case class AutoCloseClient(client: DbClient, closeFn: () => Unit) extends AutoCloseable:
    export client.*
    def close(): Unit =
      closeFn()
  end AutoCloseClient

  def dbClient: Task[() => AutoCloseClient] = Task.Worker:
    Class.forName("org.duckdb.DuckDBDriver")
    val fn = () =>
      val conn = java.sql.DriverManager.getConnection(s"jdbc:duckdb:$dbPath")
      val client = DbClient.Connection(conn)
      AutoCloseClient(client, conn.close)
    Using.resource(fn()): conn =>
      conn
        .getAutoCommitClientConnection
        .updateRaw(os.read(createTablesSQL().path))

    fn
  end dbClient

  case class Experiment[T[_]](
    id: T[Int],
    github: T[String],
    branch: T[String],
    startTime: T[LocalDateTime],
    endTime: T[LocalDateTime],
  )
  object Experiment extends Table[Experiment]
  
  case class Trace[T[_]](
    id: T[Int],
    experimentId: T[Int],
    trace: T[geny.Bytes],
  )
  object Trace extends Table[Trace]

  case class GatherLog[T[_]](
    id: T[Int],
    name: T[String],
    experimentId: T[Int],
    text: T[String],
  )
  object GatherLog extends Table[GatherLog]

  case class Validation[T[_]](
    id: T[Int],
    experimentId: T[Int],
    logTxt: T[String],
    counterExampleBin: T[geny.Bytes],
  )
  object Validation extends Table[Validation]
end evalDB

def tracelinkWorkloadHPP: T[PathRef] =
  Task.Source(os.sub / "tracelink-workload.hpp")

def traceOpsTLA: T[PathRef] =
  Task.Source(os.sub / "__TraceOps.tla")

final class EnoughTraces() extends RuntimeException("enough traces")
final class EnoughExperiments() extends RuntimeException("enough experiments")

object wiredtiger extends Module:
end wiredtiger

object chromatictree extends TraceEvalSpecModule:
  def origin = "git@github.com:ubc-systopia/augmented-chromatic-trees.git"
  def spec = Task.Source(os.sub / "ChromaticTree.tla")
  def mainCPP = Task.Source(os.sub / "main.cpp")

  def mcChromaticTreeValidateTLA = Task.Source(os.sub / "MCChromaticTreeValidate.tla")

  trait VariantModule extends Cross.Module[String]:
    def dsSubFolder: T[os.SubPath] = os.SubPath(crossValue)

    def patchedDir: T[PathRef] = Task:
      performPatch(
        src = gitRepo(chromatictreeRepo, chromatictreeBranches.head).dir().path,
        patchSeq = List(
          (dsSubFolder() / "workload-meta.hpp", specHPP().path),
          (dsSubFolder() / "tracelink-workload.hpp", tracelinkWorkloadHPP().path),
          (dsSubFolder() / "main.cpp", mainCPP().path),
        ),
        destDir = Task.dest / "dir",
      )
    end patchedDir

    def tracingExecutable: T[PathRef] = Task:
      val src = patchedDir().path
      val includes = List(
        src / "common",
        src / "common" / "recordmgr",
      )
      val exeDest = Task.dest / "main"
      val p = os.proc("g++", "-g", includes.map(i => s"-I$i"), src / dsSubFolder() / "main.cpp", "-o", exeDest)
      println(s"$$ ${p.commandChunks.mkString(" ")}")
      p.call(
        stdout = os.Inherit,
        stderr = os.Inherit,
      )
      PathRef(exeDest)
    end tracingExecutable

    def gatherTrace() = Task.Command:
      val exe = tracingExecutable()

      Using.resource(evalDB.dbClient()()): db =>
        db.transaction: db =>
          val branch = chromatictreeBranches.head
          val instanceCount = db.run:
            evalDB.Experiment
              .select
              .filter: row =>
                row.github === origin
                && row.branch === branch
              .size
          if instanceCount >= tracesNeeded()
          then throw EnoughTraces()
          println(s"gathering trace #${instanceCount + 1}")

          val startTime = java.time.LocalDateTime.now()
          val result = os.proc(exe).call(
            cwd = Task.dest,
            mergeErrIntoOut = true,
            check = false,
          )
          val endTime = java.time.LocalDateTime.now()
          result.out.lines().foreach(println)

          // if result.exitCode != 0
          // then
          //   println(s"saw exit code ${result.exitCode}; check in ${Task.dest}")
          //   throw RuntimeException("trace collection failed")

          val experimentId = db.run:
            evalDB.Experiment.insert
              .columns(
                _.github := origin,
                _.branch := branch,
                _.startTime := startTime,
                _.endTime := endTime,
              )
              .returning(_.id)
              .single

          db.run:
            evalDB.GatherLog.insert
              .columns(
                _.experimentId := experimentId,
                _.name := "stdout",
                _.text := result.out.text(),
              )
          os.list(Task.dest)
            .filter(_.last.endsWith(".log"))
            .map: file =>
              db.run:
                evalDB.Trace.insert
                  .columns(
                    _.experimentId := experimentId,
                    _.trace := geny.Bytes(os.read.bytes(file)),
                  )
    end gatherTrace
  end VariantModule
  object variant extends mill.Cross[VariantModule](
    "ds/brown_ext_chromatic_augment_lf",
  )

  def validateConfigDir: T[PathRef] = Task.Source(chromatictree.moduleDir / "validate_cfg")

  def validateOneTrace() = Task.Command:
    Using.resource(evalDB.dbClient()()): db =>
      db.transaction: db =>
        val experimentIds = db.run:
          evalDB.Experiment.select
            .filter: exp =>
              evalDB.Validation.select
                .filter(_.experimentId === exp.id)
                .isEmpty
            .map(_.id)
            .take(1)

        if experimentIds.isEmpty
        then throw EnoughExperiments()
        val experimentId = experimentIds.head

        println(s"validating experiment $experimentId")
        db
          .stream:
            evalDB.Trace.select
              .filter(_.experimentId === experimentId)
              .sortBy(_.id)
              .map(_.trace)
          .zipWithIndex
          .foreach: (trace, idx) =>
            val file = Task.dest / s"trace-$idx.log"
            println(s"extracting log $idx to $file")
            os.write(file, trace.array)
        
        build.pgo.runner().run(List[os.Shellable]("workloadgen-tla", spec().path, Task.dest))

        os.copy(from = traceOpsTLA().path, to = Task.dest / "__TraceOps.tla")
        os.copy(from = mcChromaticTreeValidateTLA().path, to = Task.dest / "MCChromaticTreeValidate.tla")
        os.copy(from = validateConfigDir().path, to = Task.dest, createFolders = true, mergeFolders = true)

        build.pgo.runner().run(List[os.Shellable]("tlc", Task.dest / "MCChromaticTreeValidate.tla"))
  end validateOneTrace
end chromatictree
