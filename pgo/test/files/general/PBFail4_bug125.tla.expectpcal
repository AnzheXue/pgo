------------------------------ MODULE PBFail4 ------------------------------

EXTENDS Naturals, Sequences, TLC

CONSTANT BUFFER_SIZE
CONSTANT NUM_REPLICAS
CONSTANT NUM_CLIENTS
CONSTANT EXPLORE_FAIL

ASSUME NUM_REPLICAS > 0 /\ NUM_CLIENTS > 0

(************************
--mpcal PBFail {

    define {
        NUM_NODES == NUM_REPLICAS + NUM_CLIENTS

        CLIENT_SRC == 1
        PRIMARY_SRC == 2
        BACKUP_SRC == 3

        GET_REQ == 1
        GET_RESP == 2
        PUT_REQ == 3
        PUT_RESP == 4

        ACK_MSG == "ack-body"

        KEY1 == "KEY1"
        VALUE1 == "VALUE1"
        TEMP_VAL == "TEMP"
    }

    macro mayFail() {
        if (EXPLORE_FAIL = TRUE) {
            either {
                skip;
            } or {
                goto failLabel;
            };
        };
    }

    mapping macro TCPChannel {
        read {
            await Len($variable) > 0;
            with (msg = Head($variable)) {
                $variable := Tail($variable);
                yield msg;
            };
        }

        write {
            await Len($variable) < BUFFER_SIZE;
            yield Append($variable, $value);
        }
    }

    mapping macro FailureDetector {
        read {
            yield $variable;
        }

        write {
            yield $value;
        }
    }

    mapping macro FileSystem {
        read {
            yield $variable;
        }

        write {
            yield $value;
        }
    }

    archetype AReplica(ref net[_], ref fs[_], ref fd[_])
    variables
        msg, respBody, respTyp, idx, repMsg, rep, resp;
    {
        replicaLoop:
            while (TRUE) {
                rcvMsg:
                    either {
                        msg := net[<<self, GET_REQ>>];
                    } or {
                        msg := net[<<self, PUT_REQ>>];
                    };
                    assert(msg.to = self);
                    if (msg.srcTyp = CLIENT_SRC) {
                        goto handlePrimary;
                    } else if (msg.srcTyp = PRIMARY_SRC) {
                        goto handleBackup;
                    };

                handleBackup:
                    if (msg.typ = GET_REQ) {
                        respBody := fs[<<self, msg.body.key>>];
                        respTyp := GET_RESP;
                    } else if (msg.typ = PUT_REQ) {
                        fs[<<self, msg.body.key>>] := msg.body.value;
                        respBody := ACK_MSG;
                        respTyp := PUT_RESP;
                    };
                    resp := [from |-> self, to |-> msg.from, body |-> respBody,
                             srcTyp |-> BACKUP_SRC, typ |-> respTyp, id |-> msg.id];
                    net[<<resp.to, resp.typ>>] := resp;
                    goto replicaLoop;

                handlePrimary:
                    if (msg.typ = GET_REQ) {
                        respBody := fs[<<self, msg.body.key>>];
                        respTyp := GET_RESP;
                        goto sndResp;
                    } else if (msg.typ = PUT_REQ) {
                        fs[<<self, msg.body.key>>] := msg.body.value;
                        respBody := ACK_MSG;
                        respTyp := PUT_RESP;
                        goto sndReplicaMsg;
                    };
                    sndReplicaMsg:
                        idx := 1;
                        sndMsgLoop:
                            while (idx <= NUM_REPLICAS) {
                                sndMsg:
                                    if (fd[idx] = TRUE /\ idx # self) {
                                        repMsg := [from |-> self, to |-> idx, body |-> msg.body,
                                                   srcTyp |-> PRIMARY_SRC, typ |-> PUT_REQ,
                                                   id |-> msg.id];
                                        net[<<idx, PUT_REQ>>] := repMsg;
                                    };
                                    idx := idx + 1;
                            };
                    rcvReplicaMsg:
                        idx := 1;
                        rcvMsgLoop:
                            while (idx <= NUM_REPLICAS) {
                                rcvMsgFromReplica:
                                    if (fd[idx] = TRUE /\ idx # self) {
                                        rep := net[<<self, PUT_RESP>>];
                                        assert(rep.from = idx);
                                        assert(rep.to = self);
                                        assert(rep.body = ACK_MSG);
                                        assert(rep.srcTyp = BACKUP_SRC);
                                        assert(rep.typ = PUT_RESP);
                                        assert(rep.id = msg.id);
                                    };
                                    idx := idx + 1;
                            };
                    sndResp:
                        resp := [from |-> self, to |-> msg.from, body |-> respBody,
                                 srcTyp |-> PRIMARY_SRC, typ |-> respTyp, id |-> msg.id];
                        net[<<resp.to, resp.typ>>] := resp;
                        \* mayFail();
            };

        failLabel:
            fd[self] := FALSE;
    }

    archetype AClient(ref net[_], ref fd[_])
    variables
        req, resp, idx, body;
    {
        sndPutReq:
            idx := 1;
            sndPutReqLoop:
                while (idx <= NUM_REPLICAS) {
                    sndPutMsg:
                        if (fd[idx] = TRUE) {
                            body := [key |-> KEY1, value |-> VALUE1];
                            req := [from |-> self, to |-> idx, body |-> body,
                                    srcTyp |-> CLIENT_SRC, typ |-> PUT_REQ, id |-> 1];
                            net[<<req.to, req.typ>>] := req;
                            goto rcvPutResp;
                        };
                };
        rcvPutResp:
            if (fd[idx] = TRUE) {
                resp := net[<<self, PUT_RESP>>];
                assert(resp.to = self);
                assert(resp.body = ACK_MSG);
                assert(resp.srcTyp = PRIMARY_SRC);
                assert(resp.typ = PUT_RESP);
                assert(resp.id = 1);
                print <<"PUT RESP: ", resp>>;
            } else {
                goto sndPutReq;
            };

        sndGetReq:
            idx := 1;
            sndGetReqLoop:
                while (idx <= NUM_REPLICAS) {
                    sndGetMsg:
                        if (fd[idx] = TRUE) {
                            body := [key |-> KEY1, value |-> TEMP_VAL];
                            req := [from |-> self, to |-> idx, body |-> body,
                                    srcTyp |-> CLIENT_SRC, typ |-> GET_REQ, id |-> 2];
                            net[<<req.to, req.typ>>] := req;
                            goto rcvGetResp;
                        };
                };
        rcvGetResp:
            if (fd[idx] = TRUE) {
                resp := net[<<self, GET_RESP>>];
                assert(resp.to = self);
                assert(resp.body = VALUE1);
                assert(resp.typ = GET_RESP);
                assert(resp.id = 2);
                print <<"GET RESP: ", resp>>;
            } else {
                goto sndGetReq;
            };
    }

    variables
        network = [id \in 1..NUM_NODES, typ \in 1..4 |-> <<>>];
        fd = [id \in 1..NUM_NODES |-> TRUE];
        fs = [id \in 1..NUM_NODES, key \in {KEY1} |-> <<>>];

    fair process (Replica \in 1..NUM_REPLICAS) == instance AReplica(ref network[_], ref fs[_], ref fd[_])
        mapping network[_] via TCPChannel
        mapping fs[_] via FileSystem
        mapping fd[_] via FailureDetector;

    fair process (Client \in (NUM_REPLICAS+1)..(NUM_REPLICAS+NUM_CLIENTS)) == instance AClient(ref network[_], ref fd[_])
        mapping network[_] via TCPChannel
        mapping fd[_] via FailureDetector;
}

\* BEGIN PLUSCAL TRANSLATION
--algorithm PBFail {
  variables network = [id \in (1) .. (NUM_NODES), typ \in (1) .. (4) |-> <<>>]; fd = [id \in (1) .. (NUM_NODES) |-> TRUE]; fs = [id \in (1) .. (NUM_NODES), key \in {KEY1} |-> <<>>];
  define{
    NUM_NODES == (NUM_REPLICAS) + (NUM_CLIENTS)
    CLIENT_SRC == 1
    PRIMARY_SRC == 2
    BACKUP_SRC == 3
    GET_REQ == 1
    GET_RESP == 2
    PUT_REQ == 3
    PUT_RESP == 4
    ACK_MSG == "ack-body"
    KEY1 == "KEY1"
    VALUE1 == "VALUE1"
    TEMP_VAL == "TEMP"
  }
  
  fair process (Replica \in (1) .. (NUM_REPLICAS))
    variables msg; respBody; respTyp; idx; repMsg; rep; resp;
  {
    replicaLoop:
      if (TRUE) {
        goto rcvMsg;
      } else {
        goto failLabel;
      };
    rcvMsg:
      either {
        await (Len((network)[<<self, GET_REQ>>])) > (0);
        with (msg00 = Head((network)[<<self, GET_REQ>>])) {
          network := [network EXCEPT ![<<self, GET_REQ>>] = Tail((network)[<<self, GET_REQ>>])];
          with (yielded_network4 = msg00) {
            msg := yielded_network4;
            assert ((msg).to) = (self);
            if (((msg).srcTyp) = (CLIENT_SRC)) {
              goto handlePrimary;
            } else {
              if (((msg).srcTyp) = (PRIMARY_SRC)) {
                goto handleBackup;
              } else {
                goto handleBackup;
              };
            };
          };
        };
      } or {
        await (Len((network)[<<self, PUT_REQ>>])) > (0);
        with (msg10 = Head((network)[<<self, PUT_REQ>>])) {
          network := [network EXCEPT ![<<self, PUT_REQ>>] = Tail((network)[<<self, PUT_REQ>>])];
          with (yielded_network00 = msg10) {
            msg := yielded_network00;
            assert ((msg).to) = (self);
            if (((msg).srcTyp) = (CLIENT_SRC)) {
              goto handlePrimary;
            } else {
              if (((msg).srcTyp) = (PRIMARY_SRC)) {
                goto handleBackup;
              } else {
                goto handleBackup;
              };
            };
          };
        };
      };
    handleBackup:
      if (((msg).typ) = (GET_REQ)) {
        with (yielded_fs1 = (fs)[<<self, ((msg).body).key>>]) {
          respBody := yielded_fs1;
          respTyp := GET_RESP;
          resp := [from |-> self, to |-> (msg).from, body |-> respBody, srcTyp |-> BACKUP_SRC, typ |-> respTyp, id |-> (msg).id];
          with (value10 = resp) {
            await (Len((network)[<<(resp).to, (resp).typ>>])) < (BUFFER_SIZE);
            network := [network EXCEPT ![<<(resp).to, (resp).typ>>] = Append((network)[<<(resp).to, (resp).typ>>], value10)];
            goto replicaLoop;
          };
        };
      } else {
        if (((msg).typ) = (PUT_REQ)) {
          with (value00 = ((msg).body).value) {
            fs := [fs EXCEPT ![<<self, ((msg).body).key>>] = value00];
            respBody := ACK_MSG;
            respTyp := PUT_RESP;
            resp := [from |-> self, to |-> (msg).from, body |-> respBody, srcTyp |-> BACKUP_SRC, typ |-> respTyp, id |-> (msg).id];
            with (value11 = resp) {
              await (Len((network)[<<(resp).to, (resp).typ>>])) < (BUFFER_SIZE);
              network := [network EXCEPT ![<<(resp).to, (resp).typ>>] = Append((network)[<<(resp).to, (resp).typ>>], value11)];
              goto replicaLoop;
            };
          };
        } else {
          resp := [from |-> self, to |-> (msg).from, body |-> respBody, srcTyp |-> BACKUP_SRC, typ |-> respTyp, id |-> (msg).id];
          with (value12 = resp) {
            await (Len((network)[<<(resp).to, (resp).typ>>])) < (BUFFER_SIZE);
            network := [network EXCEPT ![<<(resp).to, (resp).typ>>] = Append((network)[<<(resp).to, (resp).typ>>], value12)];
            goto replicaLoop;
          };
        };
      };
    handlePrimary:
      if (((msg).typ) = (GET_REQ)) {
        with (yielded_fs00 = (fs)[<<self, ((msg).body).key>>]) {
          respBody := yielded_fs00;
          respTyp := GET_RESP;
          goto sndResp;
        };
      } else {
        if (((msg).typ) = (PUT_REQ)) {
          with (value20 = ((msg).body).value) {
            fs := [fs EXCEPT ![<<self, ((msg).body).key>>] = value20];
            respBody := ACK_MSG;
            respTyp := PUT_RESP;
            goto sndReplicaMsg;
          };
        } else {
          goto sndReplicaMsg;
        };
      };
    sndReplicaMsg:
      idx := 1;
      goto sndMsgLoop;
    sndMsgLoop:
      if ((idx) <= (NUM_REPLICAS)) {
        goto sndMsg;
      } else {
        goto rcvReplicaMsg;
      };
    sndMsg:
      with (yielded_fd5 = (fd)[idx]) {
        if (((yielded_fd5) = (TRUE)) /\ ((idx) # (self))) {
          repMsg := [from |-> self, to |-> idx, body |-> (msg).body, srcTyp |-> PRIMARY_SRC, typ |-> PUT_REQ, id |-> (msg).id];
          with (value30 = repMsg) {
            await (Len((network)[<<idx, PUT_REQ>>])) < (BUFFER_SIZE);
            network := [network EXCEPT ![<<idx, PUT_REQ>>] = Append((network)[<<idx, PUT_REQ>>], value30)];
            idx := (idx) + (1);
            goto sndMsgLoop;
          };
        } else {
          idx := (idx) + (1);
          goto sndMsgLoop;
        };
      };
    rcvReplicaMsg:
      idx := 1;
      goto rcvMsgLoop;
    rcvMsgLoop:
      if ((idx) <= (NUM_REPLICAS)) {
        goto rcvMsgFromReplica;
      } else {
        goto sndResp;
      };
    rcvMsgFromReplica:
      with (yielded_fd00 = (fd)[idx]) {
        if (((yielded_fd00) = (TRUE)) /\ ((idx) # (self))) {
          await (Len((network)[<<self, PUT_RESP>>])) > (0);
          with (msg20 = Head((network)[<<self, PUT_RESP>>])) {
            network := [network EXCEPT ![<<self, PUT_RESP>>] = Tail((network)[<<self, PUT_RESP>>])];
            with (yielded_network10 = msg20) {
              rep := yielded_network10;
              assert ((rep).from) = (idx);
              assert ((rep).to) = (self);
              assert ((rep).body) = (ACK_MSG);
              assert ((rep).srcTyp) = (BACKUP_SRC);
              assert ((rep).typ) = (PUT_RESP);
              assert ((rep).id) = ((msg).id);
              idx := (idx) + (1);
              goto rcvMsgLoop;
            };
          };
        } else {
          idx := (idx) + (1);
          goto rcvMsgLoop;
        };
      };
    sndResp:
      resp := [from |-> self, to |-> (msg).from, body |-> respBody, srcTyp |-> PRIMARY_SRC, typ |-> respTyp, id |-> (msg).id];
      with (value40 = resp) {
        await (Len((network)[<<(resp).to, (resp).typ>>])) < (BUFFER_SIZE);
        network := [network EXCEPT ![<<(resp).to, (resp).typ>>] = Append((network)[<<(resp).to, (resp).typ>>], value40)];
        goto replicaLoop;
      };
    failLabel:
      with (value50 = FALSE) {
        fd := [fd EXCEPT ![self] = value50];
        goto Done;
      };
  }
  
  fair process (Client \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)))
    variables req; resp0; idx0; body;
  {
    sndPutReq:
      idx0 := 1;
      goto sndPutReqLoop;
    sndPutReqLoop:
      if ((idx0) <= (NUM_REPLICAS)) {
        goto sndPutMsg;
      } else {
        goto rcvPutResp;
      };
    sndPutMsg:
      with (yielded_fd1 = (fd)[idx0]) {
        if ((yielded_fd1) = (TRUE)) {
          body := [key |-> KEY1, value |-> VALUE1];
          req := [from |-> self, to |-> idx0, body |-> body, srcTyp |-> CLIENT_SRC, typ |-> PUT_REQ, id |-> 1];
          with (value60 = req) {
            await (Len((network)[<<(req).to, (req).typ>>])) < (BUFFER_SIZE);
            network := [network EXCEPT ![<<(req).to, (req).typ>>] = Append((network)[<<(req).to, (req).typ>>], value60)];
            goto rcvPutResp;
          };
        } else {
          goto sndPutReqLoop;
        };
      };
    rcvPutResp:
      with (yielded_fd2 = (fd)[idx0]) {
        if ((yielded_fd2) = (TRUE)) {
          await (Len((network)[<<self, PUT_RESP>>])) > (0);
          with (msg30 = Head((network)[<<self, PUT_RESP>>])) {
            network := [network EXCEPT ![<<self, PUT_RESP>>] = Tail((network)[<<self, PUT_RESP>>])];
            with (yielded_network20 = msg30) {
              resp0 := yielded_network20;
              assert ((resp0).to) = (self);
              assert ((resp0).body) = (ACK_MSG);
              assert ((resp0).srcTyp) = (PRIMARY_SRC);
              assert ((resp0).typ) = (PUT_RESP);
              assert ((resp0).id) = (1);
              print <<"PUT RESP: ", resp0>>;
              goto sndGetReq;
            };
          };
        } else {
          goto sndPutReq;
        };
      };
    sndGetReq:
      idx0 := 1;
      goto sndGetReqLoop;
    sndGetReqLoop:
      if ((idx0) <= (NUM_REPLICAS)) {
        goto sndGetMsg;
      } else {
        goto rcvGetResp;
      };
    sndGetMsg:
      with (yielded_fd3 = (fd)[idx0]) {
        if ((yielded_fd3) = (TRUE)) {
          body := [key |-> KEY1, value |-> TEMP_VAL];
          req := [from |-> self, to |-> idx0, body |-> body, srcTyp |-> CLIENT_SRC, typ |-> GET_REQ, id |-> 2];
          with (value70 = req) {
            await (Len((network)[<<(req).to, (req).typ>>])) < (BUFFER_SIZE);
            network := [network EXCEPT ![<<(req).to, (req).typ>>] = Append((network)[<<(req).to, (req).typ>>], value70)];
            goto rcvGetResp;
          };
        } else {
          goto sndGetReqLoop;
        };
      };
    rcvGetResp:
      with (yielded_fd4 = (fd)[idx0]) {
        if ((yielded_fd4) = (TRUE)) {
          await (Len((network)[<<self, GET_RESP>>])) > (0);
          with (msg40 = Head((network)[<<self, GET_RESP>>])) {
            network := [network EXCEPT ![<<self, GET_RESP>>] = Tail((network)[<<self, GET_RESP>>])];
            with (yielded_network30 = msg40) {
              resp0 := yielded_network30;
              assert ((resp0).to) = (self);
              assert ((resp0).body) = (VALUE1);
              assert ((resp0).typ) = (GET_RESP);
              assert ((resp0).id) = (2);
              print <<"GET RESP: ", resp0>>;
              goto Done;
            };
          };
        } else {
          goto sndGetReq;
        };
      };
  }
}

\* END PLUSCAL TRANSLATION


************************)
\* BEGIN TRANSLATION (chksum(pcal) = "e615913a" /\ chksum(tla) = "af0a484")
CONSTANT defaultInitValue
VARIABLES pc, network, fd, fs

(* define statement *)
NUM_NODES == (NUM_REPLICAS) + (NUM_CLIENTS)
CLIENT_SRC == 1
PRIMARY_SRC == 2
BACKUP_SRC == 3
GET_REQ == 1
GET_RESP == 2
PUT_REQ == 3
PUT_RESP == 4
ACK_MSG == "ack-body"
KEY1 == "KEY1"
VALUE1 == "VALUE1"
TEMP_VAL == "TEMP"

VARIABLES msg, respBody, respTyp, idx, repMsg, rep, resp, req, resp0, idx0, 
          body

vars == << pc, network, fd, fs, msg, respBody, respTyp, idx, repMsg, rep, 
           resp, req, resp0, idx0, body >>

ProcSet == ((1) .. (NUM_REPLICAS)) \cup (((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)))

Init == (* Global variables *)
        /\ network = [id \in (1) .. (NUM_NODES), typ \in (1) .. (4) |-> <<>>]
        /\ fd = [id \in (1) .. (NUM_NODES) |-> TRUE]
        /\ fs = [id \in (1) .. (NUM_NODES), key \in {KEY1} |-> <<>>]
        (* Process Replica *)
        /\ msg = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ respBody = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ respTyp = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ idx = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ repMsg = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ rep = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        /\ resp = [self \in (1) .. (NUM_REPLICAS) |-> defaultInitValue]
        (* Process Client *)
        /\ req = [self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) |-> defaultInitValue]
        /\ resp0 = [self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) |-> defaultInitValue]
        /\ idx0 = [self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) |-> defaultInitValue]
        /\ body = [self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) |-> defaultInitValue]
        /\ pc = [self \in ProcSet |-> CASE self \in (1) .. (NUM_REPLICAS) -> "replicaLoop"
                                        [] self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) -> "sndPutReq"]

replicaLoop(self) == /\ pc[self] = "replicaLoop"
                     /\ IF TRUE
                           THEN /\ pc' = [pc EXCEPT ![self] = "rcvMsg"]
                           ELSE /\ pc' = [pc EXCEPT ![self] = "failLabel"]
                     /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                     idx, repMsg, rep, resp, req, resp0, idx0, 
                                     body >>

rcvMsg(self) == /\ pc[self] = "rcvMsg"
                /\ \/ /\ (Len((network)[<<self, GET_REQ>>])) > (0)
                      /\ LET msg00 == Head((network)[<<self, GET_REQ>>]) IN
                           /\ network' = [network EXCEPT ![<<self, GET_REQ>>] = Tail((network)[<<self, GET_REQ>>])]
                           /\ LET yielded_network4 == msg00 IN
                                /\ msg' = [msg EXCEPT ![self] = yielded_network4]
                                /\ Assert(((msg'[self]).to) = (self), 
                                          "Failure of assertion at line 268, column 13.")
                                /\ IF ((msg'[self]).srcTyp) = (CLIENT_SRC)
                                      THEN /\ pc' = [pc EXCEPT ![self] = "handlePrimary"]
                                      ELSE /\ IF ((msg'[self]).srcTyp) = (PRIMARY_SRC)
                                                 THEN /\ pc' = [pc EXCEPT ![self] = "handleBackup"]
                                                 ELSE /\ pc' = [pc EXCEPT ![self] = "handleBackup"]
                   \/ /\ (Len((network)[<<self, PUT_REQ>>])) > (0)
                      /\ LET msg10 == Head((network)[<<self, PUT_REQ>>]) IN
                           /\ network' = [network EXCEPT ![<<self, PUT_REQ>>] = Tail((network)[<<self, PUT_REQ>>])]
                           /\ LET yielded_network00 == msg10 IN
                                /\ msg' = [msg EXCEPT ![self] = yielded_network00]
                                /\ Assert(((msg'[self]).to) = (self), 
                                          "Failure of assertion at line 286, column 13.")
                                /\ IF ((msg'[self]).srcTyp) = (CLIENT_SRC)
                                      THEN /\ pc' = [pc EXCEPT ![self] = "handlePrimary"]
                                      ELSE /\ IF ((msg'[self]).srcTyp) = (PRIMARY_SRC)
                                                 THEN /\ pc' = [pc EXCEPT ![self] = "handleBackup"]
                                                 ELSE /\ pc' = [pc EXCEPT ![self] = "handleBackup"]
                /\ UNCHANGED << fd, fs, respBody, respTyp, idx, repMsg, rep, 
                                resp, req, resp0, idx0, body >>

handleBackup(self) == /\ pc[self] = "handleBackup"
                      /\ IF ((msg[self]).typ) = (GET_REQ)
                            THEN /\ LET yielded_fs1 == (fs)[<<self, ((msg[self]).body).key>>] IN
                                      /\ respBody' = [respBody EXCEPT ![self] = yielded_fs1]
                                      /\ respTyp' = [respTyp EXCEPT ![self] = GET_RESP]
                                      /\ resp' = [resp EXCEPT ![self] = [from |-> self, to |-> (msg[self]).from, body |-> respBody'[self], srcTyp |-> BACKUP_SRC, typ |-> respTyp'[self], id |-> (msg[self]).id]]
                                      /\ LET value10 == resp'[self] IN
                                           /\ (Len((network)[<<(resp'[self]).to, (resp'[self]).typ>>])) < (BUFFER_SIZE)
                                           /\ network' = [network EXCEPT ![<<(resp'[self]).to, (resp'[self]).typ>>] = Append((network)[<<(resp'[self]).to, (resp'[self]).typ>>], value10)]
                                           /\ pc' = [pc EXCEPT ![self] = "replicaLoop"]
                                 /\ fs' = fs
                            ELSE /\ IF ((msg[self]).typ) = (PUT_REQ)
                                       THEN /\ LET value00 == ((msg[self]).body).value IN
                                                 /\ fs' = [fs EXCEPT ![<<self, ((msg[self]).body).key>>] = value00]
                                                 /\ respBody' = [respBody EXCEPT ![self] = ACK_MSG]
                                                 /\ respTyp' = [respTyp EXCEPT ![self] = PUT_RESP]
                                                 /\ resp' = [resp EXCEPT ![self] = [from |-> self, to |-> (msg[self]).from, body |-> respBody'[self], srcTyp |-> BACKUP_SRC, typ |-> respTyp'[self], id |-> (msg[self]).id]]
                                                 /\ LET value11 == resp'[self] IN
                                                      /\ (Len((network)[<<(resp'[self]).to, (resp'[self]).typ>>])) < (BUFFER_SIZE)
                                                      /\ network' = [network EXCEPT ![<<(resp'[self]).to, (resp'[self]).typ>>] = Append((network)[<<(resp'[self]).to, (resp'[self]).typ>>], value11)]
                                                      /\ pc' = [pc EXCEPT ![self] = "replicaLoop"]
                                       ELSE /\ resp' = [resp EXCEPT ![self] = [from |-> self, to |-> (msg[self]).from, body |-> respBody[self], srcTyp |-> BACKUP_SRC, typ |-> respTyp[self], id |-> (msg[self]).id]]
                                            /\ LET value12 == resp'[self] IN
                                                 /\ (Len((network)[<<(resp'[self]).to, (resp'[self]).typ>>])) < (BUFFER_SIZE)
                                                 /\ network' = [network EXCEPT ![<<(resp'[self]).to, (resp'[self]).typ>>] = Append((network)[<<(resp'[self]).to, (resp'[self]).typ>>], value12)]
                                                 /\ pc' = [pc EXCEPT ![self] = "replicaLoop"]
                                            /\ UNCHANGED << fs, respBody, 
                                                            respTyp >>
                      /\ UNCHANGED << fd, msg, idx, repMsg, rep, req, resp0, 
                                      idx0, body >>

handlePrimary(self) == /\ pc[self] = "handlePrimary"
                       /\ IF ((msg[self]).typ) = (GET_REQ)
                             THEN /\ LET yielded_fs00 == (fs)[<<self, ((msg[self]).body).key>>] IN
                                       /\ respBody' = [respBody EXCEPT ![self] = yielded_fs00]
                                       /\ respTyp' = [respTyp EXCEPT ![self] = GET_RESP]
                                       /\ pc' = [pc EXCEPT ![self] = "sndResp"]
                                  /\ fs' = fs
                             ELSE /\ IF ((msg[self]).typ) = (PUT_REQ)
                                        THEN /\ LET value20 == ((msg[self]).body).value IN
                                                  /\ fs' = [fs EXCEPT ![<<self, ((msg[self]).body).key>>] = value20]
                                                  /\ respBody' = [respBody EXCEPT ![self] = ACK_MSG]
                                                  /\ respTyp' = [respTyp EXCEPT ![self] = PUT_RESP]
                                                  /\ pc' = [pc EXCEPT ![self] = "sndReplicaMsg"]
                                        ELSE /\ pc' = [pc EXCEPT ![self] = "sndReplicaMsg"]
                                             /\ UNCHANGED << fs, respBody, 
                                                             respTyp >>
                       /\ UNCHANGED << network, fd, msg, idx, repMsg, rep, 
                                       resp, req, resp0, idx0, body >>

sndReplicaMsg(self) == /\ pc[self] = "sndReplicaMsg"
                       /\ idx' = [idx EXCEPT ![self] = 1]
                       /\ pc' = [pc EXCEPT ![self] = "sndMsgLoop"]
                       /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                       repMsg, rep, resp, req, resp0, idx0, 
                                       body >>

sndMsgLoop(self) == /\ pc[self] = "sndMsgLoop"
                    /\ IF (idx[self]) <= (NUM_REPLICAS)
                          THEN /\ pc' = [pc EXCEPT ![self] = "sndMsg"]
                          ELSE /\ pc' = [pc EXCEPT ![self] = "rcvReplicaMsg"]
                    /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                    idx, repMsg, rep, resp, req, resp0, idx0, 
                                    body >>

sndMsg(self) == /\ pc[self] = "sndMsg"
                /\ LET yielded_fd5 == (fd)[idx[self]] IN
                     IF ((yielded_fd5) = (TRUE)) /\ ((idx[self]) # (self))
                        THEN /\ repMsg' = [repMsg EXCEPT ![self] = [from |-> self, to |-> idx[self], body |-> (msg[self]).body, srcTyp |-> PRIMARY_SRC, typ |-> PUT_REQ, id |-> (msg[self]).id]]
                             /\ LET value30 == repMsg'[self] IN
                                  /\ (Len((network)[<<idx[self], PUT_REQ>>])) < (BUFFER_SIZE)
                                  /\ network' = [network EXCEPT ![<<idx[self], PUT_REQ>>] = Append((network)[<<idx[self], PUT_REQ>>], value30)]
                                  /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                                  /\ pc' = [pc EXCEPT ![self] = "sndMsgLoop"]
                        ELSE /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                             /\ pc' = [pc EXCEPT ![self] = "sndMsgLoop"]
                             /\ UNCHANGED << network, repMsg >>
                /\ UNCHANGED << fd, fs, msg, respBody, respTyp, rep, resp, req, 
                                resp0, idx0, body >>

rcvReplicaMsg(self) == /\ pc[self] = "rcvReplicaMsg"
                       /\ idx' = [idx EXCEPT ![self] = 1]
                       /\ pc' = [pc EXCEPT ![self] = "rcvMsgLoop"]
                       /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                       repMsg, rep, resp, req, resp0, idx0, 
                                       body >>

rcvMsgLoop(self) == /\ pc[self] = "rcvMsgLoop"
                    /\ IF (idx[self]) <= (NUM_REPLICAS)
                          THEN /\ pc' = [pc EXCEPT ![self] = "rcvMsgFromReplica"]
                          ELSE /\ pc' = [pc EXCEPT ![self] = "sndResp"]
                    /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                    idx, repMsg, rep, resp, req, resp0, idx0, 
                                    body >>

rcvMsgFromReplica(self) == /\ pc[self] = "rcvMsgFromReplica"
                           /\ LET yielded_fd00 == (fd)[idx[self]] IN
                                IF ((yielded_fd00) = (TRUE)) /\ ((idx[self]) # (self))
                                   THEN /\ (Len((network)[<<self, PUT_RESP>>])) > (0)
                                        /\ LET msg20 == Head((network)[<<self, PUT_RESP>>]) IN
                                             /\ network' = [network EXCEPT ![<<self, PUT_RESP>>] = Tail((network)[<<self, PUT_RESP>>])]
                                             /\ LET yielded_network10 == msg20 IN
                                                  /\ rep' = [rep EXCEPT ![self] = yielded_network10]
                                                  /\ Assert(((rep'[self]).from) = (idx[self]), 
                                                            "Failure of assertion at line 393, column 15.")
                                                  /\ Assert(((rep'[self]).to) = (self), 
                                                            "Failure of assertion at line 394, column 15.")
                                                  /\ Assert(((rep'[self]).body) = (ACK_MSG), 
                                                            "Failure of assertion at line 395, column 15.")
                                                  /\ Assert(((rep'[self]).srcTyp) = (BACKUP_SRC), 
                                                            "Failure of assertion at line 396, column 15.")
                                                  /\ Assert(((rep'[self]).typ) = (PUT_RESP), 
                                                            "Failure of assertion at line 397, column 15.")
                                                  /\ Assert(((rep'[self]).id) = ((msg[self]).id), 
                                                            "Failure of assertion at line 398, column 15.")
                                                  /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                                                  /\ pc' = [pc EXCEPT ![self] = "rcvMsgLoop"]
                                   ELSE /\ idx' = [idx EXCEPT ![self] = (idx[self]) + (1)]
                                        /\ pc' = [pc EXCEPT ![self] = "rcvMsgLoop"]
                                        /\ UNCHANGED << network, rep >>
                           /\ UNCHANGED << fd, fs, msg, respBody, respTyp, 
                                           repMsg, resp, req, resp0, idx0, 
                                           body >>

sndResp(self) == /\ pc[self] = "sndResp"
                 /\ resp' = [resp EXCEPT ![self] = [from |-> self, to |-> (msg[self]).from, body |-> respBody[self], srcTyp |-> PRIMARY_SRC, typ |-> respTyp[self], id |-> (msg[self]).id]]
                 /\ LET value40 == resp'[self] IN
                      /\ (Len((network)[<<(resp'[self]).to, (resp'[self]).typ>>])) < (BUFFER_SIZE)
                      /\ network' = [network EXCEPT ![<<(resp'[self]).to, (resp'[self]).typ>>] = Append((network)[<<(resp'[self]).to, (resp'[self]).typ>>], value40)]
                      /\ pc' = [pc EXCEPT ![self] = "replicaLoop"]
                 /\ UNCHANGED << fd, fs, msg, respBody, respTyp, idx, repMsg, 
                                 rep, req, resp0, idx0, body >>

failLabel(self) == /\ pc[self] = "failLabel"
                   /\ LET value50 == FALSE IN
                        /\ fd' = [fd EXCEPT ![self] = value50]
                        /\ pc' = [pc EXCEPT ![self] = "Done"]
                   /\ UNCHANGED << network, fs, msg, respBody, respTyp, idx, 
                                   repMsg, rep, resp, req, resp0, idx0, body >>

Replica(self) == replicaLoop(self) \/ rcvMsg(self) \/ handleBackup(self)
                    \/ handlePrimary(self) \/ sndReplicaMsg(self)
                    \/ sndMsgLoop(self) \/ sndMsg(self)
                    \/ rcvReplicaMsg(self) \/ rcvMsgLoop(self)
                    \/ rcvMsgFromReplica(self) \/ sndResp(self)
                    \/ failLabel(self)

sndPutReq(self) == /\ pc[self] = "sndPutReq"
                   /\ idx0' = [idx0 EXCEPT ![self] = 1]
                   /\ pc' = [pc EXCEPT ![self] = "sndPutReqLoop"]
                   /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                   idx, repMsg, rep, resp, req, resp0, body >>

sndPutReqLoop(self) == /\ pc[self] = "sndPutReqLoop"
                       /\ IF (idx0[self]) <= (NUM_REPLICAS)
                             THEN /\ pc' = [pc EXCEPT ![self] = "sndPutMsg"]
                             ELSE /\ pc' = [pc EXCEPT ![self] = "rcvPutResp"]
                       /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                       idx, repMsg, rep, resp, req, resp0, 
                                       idx0, body >>

sndPutMsg(self) == /\ pc[self] = "sndPutMsg"
                   /\ LET yielded_fd1 == (fd)[idx0[self]] IN
                        IF (yielded_fd1) = (TRUE)
                           THEN /\ body' = [body EXCEPT ![self] = [key |-> KEY1, value |-> VALUE1]]
                                /\ req' = [req EXCEPT ![self] = [from |-> self, to |-> idx0[self], body |-> body'[self], srcTyp |-> CLIENT_SRC, typ |-> PUT_REQ, id |-> 1]]
                                /\ LET value60 == req'[self] IN
                                     /\ (Len((network)[<<(req'[self]).to, (req'[self]).typ>>])) < (BUFFER_SIZE)
                                     /\ network' = [network EXCEPT ![<<(req'[self]).to, (req'[self]).typ>>] = Append((network)[<<(req'[self]).to, (req'[self]).typ>>], value60)]
                                     /\ pc' = [pc EXCEPT ![self] = "rcvPutResp"]
                           ELSE /\ pc' = [pc EXCEPT ![self] = "sndPutReqLoop"]
                                /\ UNCHANGED << network, req, body >>
                   /\ UNCHANGED << fd, fs, msg, respBody, respTyp, idx, repMsg, 
                                   rep, resp, resp0, idx0 >>

rcvPutResp(self) == /\ pc[self] = "rcvPutResp"
                    /\ LET yielded_fd2 == (fd)[idx0[self]] IN
                         IF (yielded_fd2) = (TRUE)
                            THEN /\ (Len((network)[<<self, PUT_RESP>>])) > (0)
                                 /\ LET msg30 == Head((network)[<<self, PUT_RESP>>]) IN
                                      /\ network' = [network EXCEPT ![<<self, PUT_RESP>>] = Tail((network)[<<self, PUT_RESP>>])]
                                      /\ LET yielded_network20 == msg30 IN
                                           /\ resp0' = [resp0 EXCEPT ![self] = yielded_network20]
                                           /\ Assert(((resp0'[self]).to) = (self), 
                                                     "Failure of assertion at line 456, column 15.")
                                           /\ Assert(((resp0'[self]).body) = (ACK_MSG), 
                                                     "Failure of assertion at line 457, column 15.")
                                           /\ Assert(((resp0'[self]).srcTyp) = (PRIMARY_SRC), 
                                                     "Failure of assertion at line 458, column 15.")
                                           /\ Assert(((resp0'[self]).typ) = (PUT_RESP), 
                                                     "Failure of assertion at line 459, column 15.")
                                           /\ Assert(((resp0'[self]).id) = (1), 
                                                     "Failure of assertion at line 460, column 15.")
                                           /\ PrintT(<<"PUT RESP: ", resp0'[self]>>)
                                           /\ pc' = [pc EXCEPT ![self] = "sndGetReq"]
                            ELSE /\ pc' = [pc EXCEPT ![self] = "sndPutReq"]
                                 /\ UNCHANGED << network, resp0 >>
                    /\ UNCHANGED << fd, fs, msg, respBody, respTyp, idx, 
                                    repMsg, rep, resp, req, idx0, body >>

sndGetReq(self) == /\ pc[self] = "sndGetReq"
                   /\ idx0' = [idx0 EXCEPT ![self] = 1]
                   /\ pc' = [pc EXCEPT ![self] = "sndGetReqLoop"]
                   /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                   idx, repMsg, rep, resp, req, resp0, body >>

sndGetReqLoop(self) == /\ pc[self] = "sndGetReqLoop"
                       /\ IF (idx0[self]) <= (NUM_REPLICAS)
                             THEN /\ pc' = [pc EXCEPT ![self] = "sndGetMsg"]
                             ELSE /\ pc' = [pc EXCEPT ![self] = "rcvGetResp"]
                       /\ UNCHANGED << network, fd, fs, msg, respBody, respTyp, 
                                       idx, repMsg, rep, resp, req, resp0, 
                                       idx0, body >>

sndGetMsg(self) == /\ pc[self] = "sndGetMsg"
                   /\ LET yielded_fd3 == (fd)[idx0[self]] IN
                        IF (yielded_fd3) = (TRUE)
                           THEN /\ body' = [body EXCEPT ![self] = [key |-> KEY1, value |-> TEMP_VAL]]
                                /\ req' = [req EXCEPT ![self] = [from |-> self, to |-> idx0[self], body |-> body'[self], srcTyp |-> CLIENT_SRC, typ |-> GET_REQ, id |-> 2]]
                                /\ LET value70 == req'[self] IN
                                     /\ (Len((network)[<<(req'[self]).to, (req'[self]).typ>>])) < (BUFFER_SIZE)
                                     /\ network' = [network EXCEPT ![<<(req'[self]).to, (req'[self]).typ>>] = Append((network)[<<(req'[self]).to, (req'[self]).typ>>], value70)]
                                     /\ pc' = [pc EXCEPT ![self] = "rcvGetResp"]
                           ELSE /\ pc' = [pc EXCEPT ![self] = "sndGetReqLoop"]
                                /\ UNCHANGED << network, req, body >>
                   /\ UNCHANGED << fd, fs, msg, respBody, respTyp, idx, repMsg, 
                                   rep, resp, resp0, idx0 >>

rcvGetResp(self) == /\ pc[self] = "rcvGetResp"
                    /\ LET yielded_fd4 == (fd)[idx0[self]] IN
                         IF (yielded_fd4) = (TRUE)
                            THEN /\ (Len((network)[<<self, GET_RESP>>])) > (0)
                                 /\ LET msg40 == Head((network)[<<self, GET_RESP>>]) IN
                                      /\ network' = [network EXCEPT ![<<self, GET_RESP>>] = Tail((network)[<<self, GET_RESP>>])]
                                      /\ LET yielded_network30 == msg40 IN
                                           /\ resp0' = [resp0 EXCEPT ![self] = yielded_network30]
                                           /\ Assert(((resp0'[self]).to) = (self), 
                                                     "Failure of assertion at line 500, column 15.")
                                           /\ Assert(((resp0'[self]).body) = (VALUE1), 
                                                     "Failure of assertion at line 501, column 15.")
                                           /\ Assert(((resp0'[self]).typ) = (GET_RESP), 
                                                     "Failure of assertion at line 502, column 15.")
                                           /\ Assert(((resp0'[self]).id) = (2), 
                                                     "Failure of assertion at line 503, column 15.")
                                           /\ PrintT(<<"GET RESP: ", resp0'[self]>>)
                                           /\ pc' = [pc EXCEPT ![self] = "Done"]
                            ELSE /\ pc' = [pc EXCEPT ![self] = "sndGetReq"]
                                 /\ UNCHANGED << network, resp0 >>
                    /\ UNCHANGED << fd, fs, msg, respBody, respTyp, idx, 
                                    repMsg, rep, resp, req, idx0, body >>

Client(self) == sndPutReq(self) \/ sndPutReqLoop(self) \/ sndPutMsg(self)
                   \/ rcvPutResp(self) \/ sndGetReq(self)
                   \/ sndGetReqLoop(self) \/ sndGetMsg(self)
                   \/ rcvGetResp(self)

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /\ \A self \in ProcSet: pc[self] = "Done"
               /\ UNCHANGED vars

Next == (\E self \in (1) .. (NUM_REPLICAS): Replica(self))
           \/ (\E self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)): Client(self))
           \/ Terminating

Spec == /\ Init /\ [][Next]_vars
        /\ \A self \in (1) .. (NUM_REPLICAS) : WF_vars(Replica(self))
        /\ \A self \in ((NUM_REPLICAS) + (1)) .. ((NUM_REPLICAS) + (NUM_CLIENTS)) : WF_vars(Client(self))

Termination == <>(\A self \in ProcSet: pc[self] = "Done")

\* END TRANSLATION


=============================================================================
\* Modification History
\* Last modified Thu Apr 29 00:22:21 PDT 2021 by shayan
\* Created Sat Apr 03 22:41:02 PDT 2021 by shayan
